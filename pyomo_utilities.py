"""
Author: Esteban Jiménez Rodríguez
Institution: ITESO - Universidad Jesuita de Guadalajara
Date: 01/11/2017
Description: This script contains functions that make possible to use the pyomo
library directly.
"""

from __future__ import division
import numpy as np
import pyomo.environ
import pyomo.opt
import random

################ Linear programming#############################
def dat_write_lin(f, A, b, Aeq, beq):
    # Dimensions of matrices
    m1 = b.shape[0]
    n = f.shape[0]
    m2 = beq.shape[0]

    # Creation and opening of the data file
    dat_file = open('default.dat', 'w')
    
    # Write the matrices in the data file
    dat_file.write('# This file is automatically generated by the linprog function\n');
    dat_file.write('param m1 := %i ;\nparam m2 := %i ;\nparam n := %i ;\nparam A := \n'%(m1, m2, n));
    for i in range(m1):
        for k in range(n):
            dat_file.write('%i %i %e\n'%(i+1, k+1, A[i, k]));
    dat_file.write(';\nparam b := \n');
    for i in range(m1):
        dat_file.write('%i %e\n'%(i+1, b[i]));
    dat_file.write(';\nparam Aeq := \n');
    for j in range(m2):
        for k in range(n):
            dat_file.write('%i %i %e\n'%(j+1, k+1, Aeq[j, k]));
    dat_file.write(';\nparam beq := \n');
    for j in range(m2):
        dat_file.write('%i %e\n'%(j+1, beq[j]));
    dat_file.write(';\nparam f := \n');
    for k in range(n):
        dat_file.write('%i %e\n'%(k+1, f[k]));
    dat_file.write(';');
    
    # Closing the data file
    dat_file.close()
    
def linprog_model():   
    model = pyomo.environ.AbstractModel()
    
    model.m1 = pyomo.environ.Param(within=pyomo.environ.NonNegativeIntegers)
    model.m2 = pyomo.environ.Param(within=pyomo.environ.NonNegativeIntegers)
    model.n = pyomo.environ.Param(within=pyomo.environ.NonNegativeIntegers)
    
    model.I = pyomo.environ.RangeSet(1, model.m1)
    model.J = pyomo.environ.RangeSet(1, model.m2)
    model.K = pyomo.environ.RangeSet(1, model.n)
    
    model.A = pyomo.environ.Param(model.I, model.K)
    model.b = pyomo.environ.Param(model.I)
    model.Aeq = pyomo.environ.Param(model.J, model.K)
    model.beq = pyomo.environ.Param(model.J)
    model.f = pyomo.environ.Param(model.K)
    
    # the next line declares a variable indexed by the set J
    model.x = pyomo.environ.Var(model.K, initialize = 0)
    
    def obj_expression(model):
        return pyomo.environ.summation(model.f, model.x)
    
    model.OBJ = pyomo.environ.Objective(rule=obj_expression)
    
    def ax_ineq_constraint(model, i):
        # return the expression for the inequality constraint for i
        return sum(model.A[i,k] * model.x[k] for k in model.K) <= model.b[i]
    
    def ax_eq_constraint(model, j):
        # return the expression for the equality constraint for j
        if sum(model.Aeq[j,k] * model.x[k] for k in model.K) == model.beq[j]:
            return pyomo.environ.Constraint.Feasible
        else:
            return sum(model.Aeq[j,k] * model.x[k] for k in model.K) == model.beq[j]
    
    # the next line creates one ineq constraint for each member of the set model.I
    model.AxleqbConstraint = pyomo.environ.Constraint(model.I, rule=ax_ineq_constraint)
    # the next line creates one equality constraint for each member of the set model.J
    model.AxeqbConstraint = pyomo.environ.Constraint(model.J, rule=ax_eq_constraint)

    return model
    
def linprog(f, A, b, Aeq=None, beq=None):
    # Dimensions of matrices
    m1 = b.shape[0]
    n = f.shape[0]
    
    # b must be a vector
    if b.ndim != 1:
        raise ValueError('b must be a one dimensional array')
    # A must be a matrix
    if A.ndim != 2:
        raise ValueError('A must be a two dimensional array')
    
    # Dimension check for inequality constraint
    if A.shape != (m1, n):
        raise ValueError('The shape of A must be equal to (b.shape[0], f.shape[0])')
    
    # If no equality restriction
    if np.any(Aeq == None) & np.any(beq == None):
        Aeq = np.zeros((1,n))
        beq = np.zeros((1,))
        m2 = 1
    elif (np.any(Aeq != None) & np.any(beq == None)) | (np.any(Aeq == None) & np.any(beq != None)):
        raise ValueError('Please provide Aeq and beq if there is an equality constraint. If there is not, please provide none of them.')
    else:
        # Dimension of matrices
        m2 = beq.shape[0]
        
        # beq must be a vector
        if beq.ndim != 1:
            raise ValueError('b must be a one dimensional array')
        # Aeq must be a matrix
        if Aeq.ndim != 2:
            raise ValueError('A must be a two dimensional array')
        # Dimension check for equality constraint
        if Aeq.shape != (m2, n):
            raise ValueError('The shape of Aeq must be equal to (beq.shape[0], f.shape[0])')
        
    # Data file creation
    dat_write_lin(f, A, b, Aeq, beq)
    
    # Solution
    model = linprog_model()
    # Create the model instance
    instance = model.create_instance('default.dat')
    # Setup the optimizer: linear in this case
    import pyomo.environ
    opt = pyomo.opt.SolverFactory('glpk')
    # Optimize
    results = opt.solve(instance)
    # Write the output
    results.write()
    
    # Optimal solution
    x = np.array([instance.x[k].value for k in instance.K])
    return x, pyomo.environ.value(instance.OBJ)
    
################ Curve fitting#############################
def dat_write_fit(X, y):
    # Dimensions of matrices
    n, m = X.shape

    # Creation and opening of the data file
    dat_file = open('default1.dat', 'w')
    
    # Write the matrices in the data file
    dat_file.write('# This file is automatically generated by the curve_fit function\n');
    dat_file.write('param n := %i ;\nparam m := %i ;\nparam X := \n'%(n, m));
    for i in range(n):
        for j in range(m):
            dat_file.write('%i %i %e\n'%(i+1, j+1, X[i, j]));
    dat_file.write(';\nparam y := \n');
    for i in range(n):
        dat_file.write('%i %e\n'%(i+1, y[i]));
    dat_file.write(';');
    
    # Closing the data file
    dat_file.close()
    
def fit_model(reg_mode, reg_coef, robust, m):   
    model = pyomo.environ.AbstractModel()
    
    model.n = pyomo.environ.Param(within=pyomo.environ.NonNegativeIntegers)
    model.m = pyomo.environ.Param(within=pyomo.environ.NonNegativeIntegers)
    
    model.I = pyomo.environ.RangeSet(1, model.n)
    model.J = pyomo.environ.RangeSet(1, model.m)
    
    model.X = pyomo.environ.Param(model.I, model.J)
    model.y = pyomo.environ.Param(model.I)
    
    # the next line declares a variable indexed by the set J
    model.b = pyomo.environ.Var(model.J, initialize = 10)
    
    def obj_expression(model):
        if robust == False:
            if reg_mode == None:
                return sum((sum(model.X[i, j] * model.b[j] for j in model.J) - model.y[i])**2 for i in model.I)
            elif reg_mode == 'ridge':
                if np.any(reg_coef == None):
                    raise ValueError('You must provide a coeficient for the ridge regularization mode')
                return sum((sum(model.X[i, j] * model.b[j] for j in model.J) - model.y[i])**2 for i in model.I) + reg_coef * sum(model.b[j]**2 for j in model.J)
            elif reg_mode == 'lasso':
                if np.any(reg_coef == None):
                    raise ValueError('You must provide a coeficient for the lasso regularization mode')
                return sum((sum(model.X[i, j] * model.b[j] for j in model.J) - model.y[i])**2 for i in model.I) + reg_coef * sum(np.abs(model.b[j]) for j in model.J)
            elif reg_mode == 'elastic':
                if np.any(reg_coef == None):
                    raise ValueError('You must provide a coeficient for the lasso regularization mode')
                elif np.size(reg_coef) != 2:
                    raise ValueError('You must provide two coefficients for elastic net regularization (tuple, list or numpy.ndarray)')
                return sum((sum(model.X[i, j] * model.b[j] for j in model.J) - model.y[i])**2 for i in model.I) + reg_coef[0] * sum(model.b[j]**2 for j in model.J) + reg_coef[1] * sum(np.abs(model.b[j]) for j in model.J)
        else:
            return sum(huber_fcn(sum(model.X[i, j] * model.b[j] for j in model.J) - model.y[i]) for i in model.I)
    
    model.OBJ = pyomo.environ.Objective(rule=obj_expression)

    return model
    
def curve_polyfit(x, y, order, reg_mode = None, reg_coef = None, robust = False): 
    # Dimensions of matrices
    n = x.shape[0]
    m = order
    
    # b must be a vector
    if y.ndim != 1:
        raise ValueError('y must be a one dimensional array')
    # A must be a matrix
    if x.ndim != 1:
        raise ValueError('x must be a one dimensional array')
    
    # Dimension check for inequality constraint
    if y.shape[0] != n:
        raise ValueError('The shape of y must be equal to the shape of x')
        
    # Data file creation
    X = np.array([x**j for j in range(m+1)]).T
    dat_write_fit(X, y)
    
    # Solution
    model = fit_model(reg_mode, reg_coef, robust, m)
    # Create the model instance
    instance = model.create_instance('default1.dat')
    # Setup the optimizer: linear in this case
    import pyomo.environ
    opt = pyomo.opt.SolverFactory('ipopt')    
    # Optimize
    results = opt.solve(instance)
    # Write the output
    results.write()
    
    # Optimal solution
    b = np.array([instance.b[j].value for j in instance.J])
    return b

def huber_fcn(r):
    c = 1.345
    if np.abs(pyomo.environ.value(r)) <= c:
        return r**2
    else:
        return c*(2*np.abs(r) - c)
    
    
################ Binary classifier#############################
def dat_write_clas(Xa, Y):
    # Dimensions of matrices
    m, n = Xa.shape

    # Creation and opening of the data file
    dat_file = open('default2.dat', 'w')
    
    # Write the matrices in the data file
    dat_file.write('# This file is automatically generated by the logreg_clas function\n');
    dat_file.write('param m := %i ;\nparam n := %i ;\nparam Xa := \n'%(m, n));
    for i in range(m):
        for j in range(n):
            dat_file.write('%i %i %e\n'%(i+1, j+1, Xa[i, j]));
    dat_file.write(';\nparam Y := \n');
    for i in range(m):
        dat_file.write('%i %e\n'%(i+1, Y[i]));
    dat_file.write(';');
    
    # Closing the data file
    dat_file.close()
    
def clas_model():   
    model = pyomo.environ.AbstractModel()
    
    model.m = pyomo.environ.Param(within=pyomo.environ.NonNegativeIntegers)
    model.n = pyomo.environ.Param(within=pyomo.environ.NonNegativeIntegers)
    
    model.I = pyomo.environ.RangeSet(1, model.m)
    model.J = pyomo.environ.RangeSet(1, model.n)
    
    model.Xa = pyomo.environ.Param(model.I, model.J)
    model.Y = pyomo.environ.Param(model.I)
    
    # the next line declares a variable indexed by the set J
    model.B = pyomo.environ.Var(model.J)
    
    def obj_expression(model):
        return -sum(model.Y[i]*pyomo.environ.log(fun_log(sum(model.Xa[i, j] * model.B[j] for j in model.J))) + (1-model.Y[i])*pyomo.environ.log(1-fun_log(sum(model.Xa[i, j] * model.B[j] for j in model.J))) for i in model.I)/model.m
    
    model.OBJ = pyomo.environ.Objective(rule=obj_expression)
    return model
    
def logreg_clas(X, Y):
    # Dimensions of matrices
    m, n = X.shape
    
    # Y must be a vector
    if Y.ndim != 1:
        raise ValueError('Y must be a one dimensional array')
    # Y must have m components
    if Y.shape[0] != m:
        raise ValueError('Y must be have as many components as rows have X')
    
        
    # Data file creation
    Xa = np.append(np.ones((len(Y),1)), X, axis=1)
    dat_write_clas(Xa, Y)
    
    # Solution
    model = clas_model()
    # Create the model instance
    instance = model.create_instance('default2.dat')
    # Setup the optimizer: linear in this case
    import pyomo.environ
    opt = pyomo.opt.SolverFactory('ipopt')    
    # Optimize
    results = opt.solve(instance)
    # Write the output
    results.write()
    
    # Optimal solution
    B = np.array([instance.B[j].value for j in instance.J])
    return B

def fun_log(z):
    return 1/(1+pyomo.environ.exp(-z))
